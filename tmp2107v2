D∆∞·ªõi ƒë√¢y l√† phi√™n b·∫£n extract_code.py ƒë·ªÉ t√≠ch h·ª£p v√†o h·ªá th·ªëng tr√≠ch xu·∫•t PDF c·ªßa b·∫°n, c√≥ kh·∫£ nƒÉng:

Tr√≠ch xu·∫•t to√†n b·ªô n·ªôi dung theo th·ª© t·ª± g·ªëc hi·ªÉn th·ªã (text, image, v.v.) b·∫±ng PyMuPDF.

T·ª± ƒë·ªông nh·∫≠n di·ªán ƒëo·∫°n m√£ code d·ª±a v√†o font monospace, c√∫ ph√°p code, v√† b·ªë c·ª•c d√≤ng.



---

üìÅ extractor/extract_code.py

import fitz  # PyMuPDF

def is_monospace_font(font_name):
    font_name = font_name.lower()
    return any(monofont in font_name for monofont in ["mono", "courier", "consolas", "code"])

def is_code_like_text(text):
    lines = text.strip().split("\n")
    if len(lines) < 2:
        return False
    code_keywords = ["if ", "for ", "while ", "def ", "class ", "{", "}", "import ", "console.", "System."]
    code_score = sum(any(keyword in line for keyword in code_keywords) for line in lines)
    return code_score / len(lines) > 0.5  # >= 50% d√≤ng gi·ªëng code

def extract_content_with_code_detection(pdf_path, page_number):
    doc = fitz.open(pdf_path)
    page = doc[page_number]
    blocks = page.get_text("dict")["blocks"]

    extracted = []

    for block in blocks:
        bbox = block["bbox"]

        if block["type"] == 0:  # Text block
            full_text = ""
            is_mono = False

            for line in block["lines"]:
                for span in line["spans"]:
                    text = span["text"]
                    font = span["font"]
                    full_text += text + "\n"

                    if is_monospace_font(font):
                        is_mono = True

            block_type = "code" if is_mono or is_code_like_text(full_text) else "text"

            extracted.append({
                "type": block_type,
                "content": full_text.strip(),
                "bbox": bbox
            })

        elif block["type"] == 1:  # Image block
            extracted.append({
                "type": "image",
                "content": "Image block",
                "bbox": bbox
            })

    return extracted


---

‚úÖ C√°ch d√πng trong main.py

Thay v√¨ g·ªçi extract_text_by_page hay extract_images_by_page, b·∫°n g·ªçi 1 l·∫ßn:

from extractor.extract_code import extract_content_with_code_detection

def extract_pdf_content(pdf_path):
    doc = fitz.open(pdf_path)
    final_output = []

    for page_num in range(len(doc)):
        print(f"Processing page {page_num + 1}")

        # T√≠ch h·ª£p tr√≠ch xu·∫•t text + image + code
        elements = extract_content_with_code_detection(pdf_path, page_num)

        # Sort theo top-down
        ordered = sorted(elements, key=lambda x: (-x["bbox"][1], x["bbox"][0]))

        final_output.append({
            "page": page_num + 1,
            "content": ordered
        })

    return final_output


---

üß™ V√≠ d·ª• k·∫øt qu·∫£ (tr√≠ch trang PDF c√≥ code):

{
  "page": 1,
  "content": [
    {
      "type": "text",
      "content": "Introduction to programming...",
      "bbox": [...]
    },
    {
      "type": "code",
      "content": "def hello():\n    print('Hello world')",
      "bbox": [...]
    },
    {
      "type": "image",
      "content": "Image block",
      "bbox": [...]
    }
  ]
}


---

üì¶ T√≥m t·∫Øt

D√πng PyMuPDF.get_text("dict") ƒë·ªÉ ƒë·∫£m b·∫£o th·ª© t·ª± block ƒë√∫ng nh∆∞ PDF g·ªëc.

D·ª±a v√†o font v√† n·ªôi dung ƒë·ªÉ nh·∫≠n di·ªán ƒëo·∫°n m√£ ngu·ªìn (code).

D·ªÖ m·ªü r·ªông n·∫øu b·∫°n mu·ªën xu·∫•t ra Markdown, JSON, HTML, ho·∫∑c ƒë∆∞a v√†o h·ªá th·ªëng RAG.



---

B·∫°n mu·ªën m√¨nh zip l·∫°i project m·∫´u v·ªõi to√†n b·ªô th∆∞ m·ª•c extractor/ + main.py ƒë·ªÉ b·∫°n test nhanh kh√¥ng?

